\chapter{Propuesta}
\label{chap:propuesta}
La propuesta presentada en este trabajo consiste en la generación de un \textbf{framework}
para evaluar la continuidad de desarrollo de un producto de software. Este
framework tiene su base en la serie ISO 25000. De esta serie se han extraído un 
subconjunto de características y subcaracterísticas
que permiten construir un modelo que apunta a la evaluación de la continuidad de desarrollo.
Esta ISO también ha sido utilizada como base para generar un esquema de trabajo y de
las tareas fundamentales a la hora de llevar a cabo una evaluación sobre un producto real.

La elección de las métricas que dan valor a cada subcaracterística se ha realizado a través
de un análisis de la litetura y a través del criterio del autor,
tomando en cuenta el refinamiento y evolución que los distintos enfoques 
de mantenibilidad han tenido durante los años, así como los requerimientos actuales
en la industria del software. Junto a estas métricas, se presentan también las condiciones
bajo las cuales el producto se debe considerar como mantenible o inmantenible de acuerdo
a los resultados obtenidos luego de la ejecución de la evaluación.

Utilizando esta propuesta se podrá llevar a cabo la construcción, aplicación y análisis
de resultados de una evaluación de calidad de la continuidad de desarrollo de un producto
de software real.

A continuación se presentan más detalles acerca de los elementos fundamentales que componen
el framework de evaluación de continuidad.


\section{ISO 25000}

La serie de estándares ISO/IEC 25000 se denomina SQuaRE (Software product
Quality Requirements and Evaluation) y se compone de la siguientes divisiones~\cite{25000}:

\begin{itemize}
    \item ISO/IEC 2500n - División de Gestión de Calidad
    \item ISO/IEC 2501n - División de Modelo de Calidad
    \item ISO/IEC 2502n - División de Medición de Calidad
    \item ISO/IEC 2503n - División de Requerimientos de Calidad
    \item ISO/IEC 2504n - División de Evaluación de Calidad
\end{itemize}

Cada una de estas divisiones entrega estándares y guías para realizar
el proceso de análisis de calidad correspondiente.

En SQuaRE se entregan:
\begin{itemize}
    \item Términos y definiciones
    \item Modelos de referencia
    \item Guía general
    \item Guías individuales para cada división
    \item Estándares para distintos propósitos tales como especificación de requerimientos,
    planeación y gestión, medición y evaluación.
\end{itemize}

SQuaRE reemplaza a las series ISO/IEC 9126 y 14598.

Para la construcción del framework de evaluación se utilizaron 
principalmente la división de Modelo de Calidad, de la cual
se obtuvo un conjunto de características  y subcaracterísticas enfocadas en la mantenibilidad del 
producto, y la división de Evaluación de Calidad, de la cual se obtuvieron
guías para aplicar el modelo obtenido y hacer una evaluación de calidad
sobre un producto de software real.

\section{ISO/IEC 25010}

Este estándar define~\cite{25010}:

\begin{enumerate}
    \item Un modelo de \textbf{calidad en uso} compuesto de cinco características
    relacionadas con el resultado de la interacción cuando un producto es utilizado
    en un contexto de uso particular. Este modelo es aplicable al sistema
    humano-computador completo, incluyendo los sistemas computacionales en uso
    y los productos de software en uso.
    \item Un modelo de \textbf{calidad de producto} compuesto de 8 características relacionadas
    con las propiedades estáticas de un software y propiedades dinámicas de un sistema
    computacional. El modelo es aplicable a los sistemas computacionales y productos
    de software.
\end{enumerate}

Como en este caso se desea evaluar un producto de software, específicamente
su mantenibilidad, no se utilizarán características del modelo para calidad
en uso. Sólo se utilizará un conjunto del modelo para calidad de producto.
El interés está en las propiedades estáticas del sistema, las cuales
a través de su correctitud y adherencia a estándares y buenas prácticas, nos
entregarán información acerca de la mantenibilidad del producto y por ende
de su continuidad de desarrollo.

\subsection{Modelo de Calidad de Producto}
Este modelo se compone de las siguientes características y subcaracterísticas:

\begin{itemize}
\item Adecuación Funcional
    \begin{itemize}
        \item Completitud funcional
        \item Correctitud funcional
        \item Adecuidad funcional
    \end{itemize}
\item Eficiencia de desempeño
    \begin{itemize}
        \item Comportamiento en el tiempo
        \item Utilización de recursos
        \item Capacidad
    \end{itemize}
\item Compatibilidad
    \begin{itemize}
        \item Co-existencia
        \item Interoperabilidad
    \end{itemize}
\item Usabilidad
    \begin{itemize}
        \item Reconocimiento de su adecuación
        \item Capacidad de ser aprendido
        \item Protección de error para el usuario
        \item Estética de interfaz de usuario
        \item Accesibilidad
    \end{itemize}
\item Confiabilidad
    \begin{itemize}
        \item Madurez
        \item Disponibilidad
        \item Tolerancia a fallos
        \item Capacidad de recuperación
    \end{itemize}
\item Seguridad
    \begin{itemize}
        \item Confidencialidad
        \item Integridad
        \item No-repudio
        \item Responsabilidad
        \item Autenticidad
    \end{itemize}
\item Mantenibilidad
    \begin{itemize}
        \item Modularidad
        \item Reusabilidad
        \item Analizabilidad
        \item Modificabilidad
        \item Capacidad de pruebas
    \end{itemize}
\item Portabilidad
    \begin{itemize}
        \item Adaptabilidad
        \item Instalabilidad
        \item Capacidad de ser reemplazado
    \end{itemize}
\end{itemize}

Este modelo es útil para especificar requerimientos, establecer mediciones y 
realizar evaluaciones de calidad. Las características definidas pueden ser utilizadas
como una lista de verificación para asegurar un tratamiento exhaustivo de
los requerimientos de calidad.

En la práctica es muy complicado medir todas las subcaracterísticas para un sistema
o producto de software de gran tamaño. De esta manera, la importancia de las 
características dependerá de los objetivos y metas del proyecto. El modelo
debe ser adaptado antes de su uso como parte de la descomposición de requerimientos
para identificar aquellas características y subcaracterísticas que son más
importantes.

Como el framework presentado en este trabajo se enfocará solamente en la
continuidad de desarrollo del producto
de software, la característica Mantenibilidad será el actor principal pero además
se consideró que la portabilidad del producto también influye en la continuidad del desarrollo.

A continuación se presenta la implementación de la propuesta.

\section{Definición del modelo}
% PRESENTAR EL MODELO CONSTRUIDO
% PRESENTAR LAS TAREAS DEL PROCESO DE EVALUACION

\subsection{Selección de métricas para mantenibilidad}
Las subcaracterísticas elegidas para mantenibilidad son \textbf{modularidad}, \textbf{reusabilidad},
\textbf{modificabilidad} y \textbf{capacidad de pruebas}.

A continuación se presentan las métricas escogidas para evaluar estas subcaracterísticas
así como el rango o valor de correctitud que debiesen tener.

\subsubsection{Cohesión Relacional (Modularidad)}
Es el número promedio de relaciones internas por tipo. Se mide utilizando:
\begin{equation*}
H=\frac{R+1}{N}
\end{equation*}
Donde $R$ es el número de relaciones internas entre tipos y el paquete, $N$ el número de tipos en el paquete.

Las clases dentro de un \textit{assembly}\footnote{biblioteca de código compilado} deben estar fuertemente 
relacionadas, de esta manera la cohesión tendrá tener un valor alto. Por otro lado, valores demasiado altos 
podrían indicar sobre-acoplamiento. Un buen rango es $1.5\leq H\leq 4.0$.

\subsubsection{LCOM (Falta de cohesión en métodos) (Modularidad)}
El principio de responsabilidad única consiste en que una clase no debe tener más de una razón para cambiar. 
Una clase con esta característica es cohesiva.

\begin{equation*}
LCOM = 1 - \frac{\sum_{f\in F}\left|M_f\right|}{\left|M\right|\times\left|F\right|}
\end{equation*}

Donde $M$ son los métodos estáticos e instancias en la clase, $F$ campos instanciados en la clase y $M_f$ 
los métodos que acceden el campo $f_i$.

En una clase que es completamente cohesionada, cada método debe acceder a cada campo instanciado:
\begin{equation*}
\sum_f \left|M_f\right| = \left|M\right|\times\left|F\right|
\end{equation*}
de manera que el $LCOM=0$.

Un valor alto de $LCOM$ generalmente quiere decir que una clase tiene una baja cohesión. Tipos en los cuales
$LCOM\ge 0.8$ y $\left|F\right|\ge 10$ y $\left|M\right|\ge 10$ podrían ser problemáticos. Sin embargo, es 
muy difícil evitar estos casos con poca cohesión.

\subsubsection{LCOM HS (Falta de cohesión de métodos Henderson-Sellers) (Modularidad)}
Esta métrica es similar a la anterior, pero toma su valor en un rango $\left[ 0-2\right]$. Un valor LCOM 
HS mayor a $1$ debería ser considerado peligroso.

\begin{equation*}
LCOM HS = M - \frac{\sum_{f\in F}\left|M_f\right|}{F}\times (M-1)
\end{equation*}
Tipos en los cuales $LCOM HS\ge 1.0$ y $\left|F\right|\ge 10$ y $\left|M\right|\ge 10$ deberían ser evitados.
Esta restricción es más fuerte (por lo tanto más fácil de satisfacer) que la descrita para $LCOM$.

\subsubsection{Acoplamiento eferente (Modularidad)}
Número de tipos en el paquete correspondiente, que dependen de tipos que están fuera del paquete.

Un valor muy alto de esta métrica podría implicar problemas de diseño. Tipos que tengan este valor muy
alto están entrelazados con muchas otras implementaciones. Mientras más alto sea el valor, mayor es el número
de responsabilidades que el tipo tiene.

\subsubsection{Acoplamiento aferente (Modularidad)}
Número de tipos fuera del paquete, que dependen de tipos que están en el paquete en evaluación.

Un valor alto de esta métrica no es necesariamente peligroso, sin embargo es interesante saber que partes 
del código son altamente utilizadas.

Esta métrica es útil especialmente cuando es igual a $0$, lo cual podría indicar un elemento de código sin 
uso. Estos casos deben ser manejados con cuidado para puntos de entrada, constructores de clases o 
finalizadores ya que estos métodos siempre tendrán un valor $0$ para acoplamiento aferente y no 
corresponden a código sin uso.

\subsubsection{Instabilidad (Modificabilidad)}

Es la razón entre el acoplamiento eferente y el acoplamiento total. Esta métrica indica la resiliencia 
al cambio del paquete.

\begin{equation*}
I = C_e / (C_e + C_a)
\end{equation*}

Donde $C_e$ es el acoplamiento eferente y $C_a$ el acoplamiento aferente.

Un valor de $I=0$ indica un paquete completamente estable, fácil de modificar. Un valor de $I=1$ indica
un paquete completamente inestable.

\subsubsection{Complejidad Ciclomática (Modificabilidad)}
Número de decisiones que pueden ser tomadas en un procedimiento.
Procedimientos con un valor mayor a 15 son difíciles de entender, mientras que con un valor mayor a 30
son extremadamente complejos y deberían ser divididos en métodos más pequeños (a menos que sea código 
auto-generado).

\subsubsection{índice de mantenibilidad (Modificabilidad)}

Corresponde a un índice entre 0 y 100 que representa la facilidad relativa
de mantener el código. Un valor más alto indica una mejor mantenibilidad. Un valor entre 20 y 100
indica que el código tiene una buena mantenibilidad. Un valor entre 10 y 19 indica que el código es
moderadamente mantenible y un código entre 0 y 9 indica una baja mantenibilidad.

\subsubsection{Profundidad (Modificabilidad, Analizabilidad)}
Estudia el nivel de anidamiento que puede existir entre funciones o expresiones dentro del código.
Se debe definir un límite crítico de profundidad y verificar que no se esté sobrepasando.

\subsubsection{Número de parámetros (Analizabilidad)}
Estudia el número de parámetros en una función.
Al reducir este valor, se puede mejorar la analizabilidad y modularidad del código de manera sustancial.
Al igual que la métrica anterior, se debe definir un valor límite para estudiar el código y verificar que
no se esté sobrepasando.

\subsubsection{Código duplicado (Reusabilidad)}

Se utiliza alguna heurística para detectar código potencialmente duplicado.
El hecho de encontrar un porcentaje alto de duplicación, podría indicar que no se está haciendo un reuso 
adecuado en el software.

\subsection{Selección de métricas para portabilidad}

\subsubsection{Prácticas de instalación (Instalabilidad)}

Descripciones cualitativas acerca de cómo se implementa una instalación estándar para el producto. 
Se estudian estos procesos y se recomiendan mejoras para alinear las prácticas a estándares profesionales.

\section{Definición de las tareas dentro del proceso de evaluación}

Las principales tareas y sub-tareas dentro del proceso de evaluación son:

\begin{enumerate}
    \item Establecer los requerimientos de la evaluación
        \begin{enumerate}
                \item Establecer el propósito de la evaluación
                \item Obtener los requerimientos de calidad del producto de software (si es que existen)
                \item Identificar las partes del producto que serán sometidas a la evaluación
                \item Definir el rigor de la evaluación (tomar en cuenta presupuestos, tiempos, propósito, etc)
        \end{enumerate}
    \item Diseñar la evaluación
        \begin{enumerate}
                \item Generar el plan de actividades de evaluación
                    Se debe tener en cuenta el presupuesto, métodos de evaluación, herramientas de evaluación, 
                    calendarización de actividades, recursos disponibles, etc.
        \end{enumerate}
    \item Ejecutar la evaluación
        \begin{enumerate}
                \item Realizar las mediciones utilizando el modelo entregado
                \item Aplicar criterios de decisión para las medidas utilizando el modelo entregado
                \item Aplicar criterios de decisión para la evaluación (tomar en cuenta los requerimientos de calidad
                    del producto)
        \end{enumerate}
    \item Concluir la evaluación
        \begin{enumerate}
            \item Revisar los resultados de la evaluación
            \item Entregar los datos de evaluación
        \end{enumerate}
\end{enumerate}

Estas actividades fueron seleccionadas utilizando las recomendaciones entregadas en la ISO 2504n~\cite{25040}.
Con estas tareas, y junto al modelo definido, se tiene un framework con el cual podemos llevar a cabo
una evaluación de calidad específicamente para evaluar la continuidad de desarrollo de un producto de software
usando como puente las métricas que definen su mantenibilidad.
Las tareas del proceso sirven para hacer un análisis previo del contexto del producto así como para prepara un informe acorde a
estándares internacionales. Además se pueden privilegiar ciertas métricas del modelo o incluso omitir algunas. 
Por ejemplo, dependiendo del tipo de arquitectura en cuestión, algunas métricas podrían no ser útiles. Un caso especial es cuando se analiza un arquitectura de lado ciente, por
ejemplo código javascript. En este tipo de sistemas, métricas que son más efectivas en sistemas orientado a objetos de lado servidor podrían carecer
de sentido (acoplamiento entre clases, cohesión relativa, etc). En este tipo de sistemas son más útiles métricas como profundidad,
número de parámetros o complejidad ciclomática.
Todos estos ajustes quedan a criterio del evaluador, el cual junto a los clientes debe analizar cada una de las tareas del procesos y así
refinar aún más el modelo de calidad.
